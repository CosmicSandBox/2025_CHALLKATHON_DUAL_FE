<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>μΉ΄μΉ΄μ¤ λ§µ μ΄λ™ κ²μ„</title>
    <script type="text/javascript" src="//dapi.kakao.com/v2/maps/sdk.js?appkey=4130719bf72a312a77503c40294d252d"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 100%;
        }
        .info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background-color: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }
        .progress-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }
        .stats {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #666;
        }
        .checkpoint-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(76, 175, 80, 0.95);
            color: white;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            font-weight: bold;
            display: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="info-overlay">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <span style="font-weight: bold; color: #333;">μ΄λ™ μ§„ν–‰λ„</span>
            <span id="progress-text" style="font-weight: bold; color: #4CAF50;">0%</span>
        </div>
        <div class="progress-bar">
            <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
        </div>
        <div class="stats">
            <span>κ±°λ¦¬: <span id="current-distance">0</span>m</span>
            <span>μµκ³ κΈ°λ΅: <span id="max-distance">3500</span>m</span>
            <span>μ²΄ν¬ν¬μΈνΈ: <span id="checkpoints">0</span></span>
        </div>
    </div>
    
    <div id="checkpoint-info" class="checkpoint-info">
        μ²΄ν¬ν¬μΈνΈ λ„λ‹¬! π‰
    </div>
    
    <div id="map"></div>

    <script>
        let map;
        let userMarker;
        let checkpointMarker;
        let checkpointCircle;
        let userPosition = null;
        let checkpointPosition = null;
        let currentDistance = 0;
        let maxDistance = 3500; // μµκ³ κΈ°λ΅ (λ°±μ—”λ“μ—μ„ λ°›μ•„μ¬ μμ •)
        let checkpointCount = 0;
        let checkpointRadius = 50; // μ΄κΈ° μ²΄ν¬ν¬μΈνΈ λ°κ²½ 50m
        let watchId = null;

        // λ§µ μ΄κΈ°ν™”
        function initMap(lat, lng) {
            const container = document.getElementById('map');
            const options = {
                center: new kakao.maps.LatLng(lat, lng),
                level: 4
            };
            
            map = new kakao.maps.Map(container, options);
            
            // μ‚¬μ©μ λ§μ»¤ μƒμ„±
            const userMarkerImage = new kakao.maps.MarkerImage(
                'data:image/svg+xml;base64,' + btoa(`
                    <svg width="30" height="30" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="15" cy="15" r="12" fill="#2196F3" stroke="white" stroke-width="3"/>
                        <circle cx="15" cy="15" r="5" fill="white"/>
                    </svg>
                `),
                new kakao.maps.Size(30, 30),
                { offset: new kakao.maps.Point(15, 15) }
            );
            
            userMarker = new kakao.maps.Marker({
                position: new kakao.maps.LatLng(lat, lng),
                map: map,
                image: userMarkerImage
            });
            
            userPosition = { lat, lng };
            
            // μ²« λ²μ§Έ μ²΄ν¬ν¬μΈνΈ μƒμ„±
            createCheckpoint();
            
            // μ„μΉ μ¶”μ  μ‹μ‘
            startLocationTracking();
        }

        // μ²΄ν¬ν¬μΈνΈ μƒμ„±
        function createCheckpoint() {
            if (checkpointMarker) {
                checkpointMarker.setMap(null);
            }
            if (checkpointCircle) {
                checkpointCircle.setMap(null);
            }
            
            // μ‚¬μ©μ μ„μΉ μ£Όλ³€μ— λλ¤ μ²΄ν¬ν¬μΈνΈ μƒμ„±
            const angle = Math.random() * 2 * Math.PI;
            const distance = checkpointRadius + Math.random() * checkpointRadius;
            
            const lat = userPosition.lat + (distance / 111000) * Math.cos(angle);
            const lng = userPosition.lng + (distance / (111000 * Math.cos(userPosition.lat * Math.PI / 180))) * Math.sin(angle);
            
            checkpointPosition = { lat, lng };
            
            // μ²΄ν¬ν¬μΈνΈ λ§μ»¤
            const checkpointMarkerImage = new kakao.maps.MarkerImage(
                'data:image/svg+xml;base64,' + btoa(`
                    <svg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="20" cy="20" r="15" fill="#FFD700" stroke="#FF8C00" stroke-width="3"/>
                        <text x="20" y="26" text-anchor="middle" font-size="16" fill="#FF8C00">β…</text>
                    </svg>
                `),
                new kakao.maps.Size(40, 40),
                { offset: new kakao.maps.Point(20, 20) }
            );
            
            checkpointMarker = new kakao.maps.Marker({
                position: new kakao.maps.LatLng(lat, lng),
                map: map,
                image: checkpointMarkerImage
            });
            
            // μ²΄ν¬ν¬μΈνΈ λ°κ²½ ν‘μ‹
            checkpointCircle = new kakao.maps.Circle({
                center: new kakao.maps.LatLng(lat, lng),
                radius: 20, // 20m λ°κ²½ λ‚΄μ— λ“¤μ–΄μ¤λ©΄ μ²΄ν¬ν¬μΈνΈ λ‹¬μ„±
                strokeWeight: 2,
                strokeColor: '#FFD700',
                strokeOpacity: 0.8,
                strokeStyle: 'dashed',
                fillColor: '#FFD700',
                fillOpacity: 0.2
            });
            
            checkpointCircle.setMap(map);
        }

        // μ„μΉ μ¶”μ  μ‹μ‘
        function startLocationTracking() {
            if (navigator.geolocation) {
                watchId = navigator.geolocation.watchPosition(
                    function(position) {
                        const newLat = position.coords.latitude;
                        const newLng = position.coords.longitude;
                        
                        // μ΄μ „ μ„μΉμ™€μ κ±°λ¦¬ κ³„μ‚°
                        if (userPosition) {
                            const distance = calculateDistance(
                                userPosition.lat, userPosition.lng,
                                newLat, newLng
                            );
                            currentDistance += distance;
                        }
                        
                        // μ‚¬μ©μ μ„μΉ μ—…λ°μ΄νΈ
                        userPosition = { lat: newLat, lng: newLng };
                        userMarker.setPosition(new kakao.maps.LatLng(newLat, newLng));
                        
                        // μ§„ν–‰λ„ μ—…λ°μ΄νΈ
                        updateProgress();
                        
                        // μ²΄ν¬ν¬μΈνΈ λ„λ‹¬ μ²΄ν¬
                        checkCheckpointReached();
                        
                        // React Nativeμ— ν„μ¬ μƒνƒ μ „μ†΅
                        sendMessageToReactNative({
                            type: 'location_update',
                            distance: Math.round(currentDistance),
                            progress: Math.min(100, (currentDistance / maxDistance) * 100),
                            checkpoints: checkpointCount
                        });
                    },
                    function(error) {
                        console.error('Location error:', error);
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 1000
                    }
                );
            }
        }

        // λ‘ μ§€μ  κ°„ κ±°λ¦¬ κ³„μ‚° (λ―Έν„°)
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 6371e3; // μ§€κµ¬ λ°μ§€λ¦„ (λ―Έν„°)
            const Ο†1 = lat1 * Math.PI/180;
            const Ο†2 = lat2 * Math.PI/180;
            const Ξ”Ο† = (lat2-lat1) * Math.PI/180;
            const Ξ”Ξ» = (lng2-lng1) * Math.PI/180;

            const a = Math.sin(Ξ”Ο†/2) * Math.sin(Ξ”Ο†/2) +
                      Math.cos(Ο†1) * Math.cos(Ο†2) *
                      Math.sin(Ξ”Ξ»/2) * Math.sin(Ξ”Ξ»/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        }

        // μ§„ν–‰λ„ μ—…λ°μ΄νΈ
        function updateProgress() {
            const progress = Math.min(100, (currentDistance / maxDistance) * 100);
            document.getElementById('progress-fill').style.width = progress + '%';
            document.getElementById('progress-text').textContent = Math.round(progress) + '%';
            document.getElementById('current-distance').textContent = Math.round(currentDistance);
            document.getElementById('checkpoints').textContent = checkpointCount;
        }

        // μ²΄ν¬ν¬μΈνΈ λ„λ‹¬ μ²΄ν¬
        function checkCheckpointReached() {
            if (checkpointPosition) {
                const distance = calculateDistance(
                    userPosition.lat, userPosition.lng,
                    checkpointPosition.lat, checkpointPosition.lng
                );
                
                if (distance <= 20) { // 20m μ΄λ‚΄ λ„λ‹¬
                    checkpointReached();
                }
            }
        }

        // μ²΄ν¬ν¬μΈνΈ λ„λ‹¬ μ²λ¦¬
        function checkpointReached() {
            checkpointCount++;
            checkpointRadius += 25; // λ°κ²½ 25mμ”© μ¦κ°€
            
            // μ²΄ν¬ν¬μΈνΈ λ‹¬μ„± μ•λ¦Ό ν‘μ‹
            const infoDiv = document.getElementById('checkpoint-info');
            infoDiv.style.display = 'block';
            setTimeout(() => {
                infoDiv.style.display = 'none';
            }, 2000);
            
            // μƒλ΅μ΄ μ²΄ν¬ν¬μΈνΈ μƒμ„±
            setTimeout(createCheckpoint, 1000);
            
            // React Nativeμ— μ²΄ν¬ν¬μΈνΈ λ‹¬μ„± μ•λ¦Ό
            sendMessageToReactNative({
                type: 'checkpoint_reached',
                checkpoints: checkpointCount,
                newRadius: checkpointRadius
            });
        }

        // React Nativeμ— λ©”μ‹μ§€ μ „μ†΅
        function sendMessageToReactNative(data) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify(data));
            }
        }

        // React Nativeμ—μ„ λ©”μ‹μ§€ μμ‹ 
        window.addEventListener('message', function(event) {
            const data = JSON.parse(event.data);
            
            if (data.type === 'init_map') {
                initMap(data.lat, data.lng);
            } else if (data.type === 'set_max_distance') {
                maxDistance = data.maxDistance;
                document.getElementById('max-distance').textContent = maxDistance;
            } else if (data.type === 'stop_tracking') {
                if (watchId) {
                    navigator.geolocation.clearWatch(watchId);
                    watchId = null;
                }
            }
        });

        // νμ΄μ§€ λ΅λ“ μ™„λ£μ‹ Ready μ‹ νΈ μ „μ†΅
        window.addEventListener('load', function() {
            sendMessageToReactNative({ type: 'map_ready' });
        });
    </script>
</body>
</html>
